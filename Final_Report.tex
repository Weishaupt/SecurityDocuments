%\documentclass[a4paper]{scrartcl}
\documentclass[a4paper,draft]{scrartcl}

\usepackage[english]{babel} %English 
%\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}	%utf8 encoding
\usepackage[colorlinks]%, %Anstatt Boxen um Links, diese einfÃ¤rben
        	{hyperref}		%Anklickbare Links

\interfootnotelinepenalty=10000 % this prevents footnotes from being split across multiple pages
%\usepackage{
%	amsmath,                 % improves quality of formulas
%   amssymb,                 % mathematical symbols
%   amsfonts,                % mathematical fonts
%   amsthm,                  % macros for theorems, lemmas, etc.
%   graphicx,                % needed to include graphics and images
%}

\newcommand{\totype}{\(\to\;\)}

\title{KeyChain Extension and Integration\\
	Final Report}
\subtitle{Practical Lab on Smartphone Security}
\author{Kjell Braden, Marvin Dickhaus, Cassius Puodzius}
\date{Winter term 2012/2013\\\today}


%%% START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
	The goal of this project is to extend the built-in key storage of Android 4.2 to support functionality such as signing and decrypting without revealing the needed key to any app.\\
	The second goal is the integration of system apps to demonstrate the functionality. This group implemented symmetrically encrypted SMS for that purpose.
\end{abstract}

\tableofcontents
%\pagebreak[4]

\section{Introduction}
	Since Android API Level\footnote{\url{http://developer.android.com/guide/topics/manifest/uses-sdk-element.html\#ApiLevels}} 14 (4.0 Ice Cream Sandwich) the \texttt{KeyChain}\footnote{\url{http://developer.android.com/reference/android/security/KeyChain.html}} class exists in Android. The \texttt{KeyChain} class allows storage of asymmetric keys in a secure credential storage.

	Whenever in the default implementation an authorized app calls to retrieve the private key, it'll get it. Our goal was to extend the given functionality further with a crypto oracle, as well as support for different key types, both symmetric and asymmetric. With that functionality, apps should call the API with the data they want en-/decrypted or signed/verified. In the process of en-/decryption and signing the API would return the respective byte data. With verifying the API would return a boolean indicating verification success or failure.
	
	Besides the new API, we wanted to alter at least one system app to comply with our enhanced KeyChain. After suggestions from Sven Bugiel (our supervisor) we decided to implement symmetric encryption with the SMS app in lieu of the E-Mail app. More on that in section \ref{sec-sms-app}.

\section{Initial Situation}
	At the starting point, we were confronted with a quite unfinished, not wholly tested API. Furthermore the KeyChain API lacks in documentation. So we had to figure out in what way it would be possible to implement our functionality.

	\subsection{Class Overview}
		\begin{description}
			\item[KeyChain] is the Android API for importing PKCS\#12 containers (private keys, public key certificates and CA certificates) and providing grant-based access of the keys to apps. The PKCS\#12 format requires the container to be encrypted. %TODO: Wikipeda states, that encryption is optional. What is the case? (Marvin)
				\begin{itemize}
					\item When an import is requested the API creates an Intent, which is handled in the system app \path{com.android.certinstaller} (source at \path{packages/apps/CertInstaller/CertInstaller.java} et al.). CertInstaller spawns a dialog and handles the container decryption process as well as stores the keys in the \texttt{keystore} daemon (see below).
					\item Keys are identified by aliases, which are chosen by the user when the CertInstaller is invoked with an import request.
					\item Private as well as public keys (in the form of certificates) can be requested:
					\begin{itemize}
						\item If access to a private key was granted to the requesting app, it can be retrieved using \texttt{getPrivateKey()}.
						\item Public keys can be retrieved through \texttt{getCertificateChain()}
					\end{itemize}
				\item \texttt{KeyChain} also contains \texttt{AndroidKeyPairGenerator} since Android 4.2, which generates and stores key pairs in \texttt{key\-store} automatically.
				\end{itemize}

			\item[KeyChain app] is a system application implementing most parts of the \texttt{KeyChain} API. It grants key access to apps and retrieves keys from the secure native \texttt{keystore} daemon (see below).

			\item[keystore] is the native deamon (written in C++) that holds encrypted key information.
				\begin{itemize}
					\item The storage is encrypted with a master key which is derived from the unlock passphrase, PIN or pattern of the device\footnote{In order to import and use certificates that are not in the trusted certificates from the Android base (known as user certificates), respectivey use the \texttt{keystore}, a PIN, passphrase or pattern has to be created, that'll unlock the device.}.
					\item Unlocks on the \emph{first successful unlock attempt} of the device, won't lock again \emph{until the phone is powered off}. This means the keystore is protected for example from rooting, but not from live-debugging. (It is possible for apps to lock it manually, though.)
					\item The service supports two storage types:
					\begin{description}
						\item[key] is a RSA keypair. Once stored the private key cannot be exported again, more on this later.
						\item[blob] can be arbitrary data.
					\end{description}
					\item \texttt{keystore} provides an OpenSSL engine called \texttt{keystore}, which should be able to retrieve PrivateKey objects from the daemon directly in Java code.
				\end{itemize}
			\item [CertInstaller] The \texttt{CertInstaller} is a system app that lets a user import and install key pairs and certificates from PKCS\#12 container format files. %TODO: Expand!
		\end{description}

	\subsection*{Detour: Java Cryptography Architecture (JCA)}
		The JCA is a {\em provider framework} for common cryptography operations such as hashing, sign/verify, encrypt/decrypt and key/certificate generation. Each of these operations have an algorithm- and	implementation-independent interface, most of which operates on objects implementing the \path{javax.crypto.SecretKey}, \path{java.security.PublicKey} or \path{java.security.PrivateKey} interfaces, depending on the context.

		This makes it possible for crypto code to be written largely independent on actual implementation e.g. of the keys.

	\section{Requirements}
		To achieve our goal, we need to be able to securely store and generate both symmetric and asymmetric keys, regardless of the key type.

		Apps should be able to do crypto operations with specific keys. In order to access those keys, the user should be required to give his permission. The operations necessary can be distinguished by the key type.
		\begin{description}
			\item[private key] For private keys, operations include decryption and signing of data.
			\item[public key] For public keys it's encryption and verification.
			\item[symmetric key] With symmetric keys, apps need to be able to both en-/decrypt, as well as sign and verify, which means generating and checking {\em message authentication codes (MAC)} in this case.
		\end{description}

		These operations must not leak any kind of private key parameter or any part of the symmetric key used.

		For convenience, it would be a good idea to create and store key exchange (eg. Diffie-Hellman) parameters as well, and to automatically derive and store the symmetric key on receiving the remote's parameters. %TODO: Explain this further.

	\subsection{Workflow with the existing KeyChain API}
		In the KeyChain API there is \texttt{AndroidKeyPairGenerator}, \texttt{AndroidKeyStore} and 
		\texttt{KeyChain}.

		The \texttt{AndroidKeyPairGenerator} implements JCA's \texttt{KeyPairGenerator} interface and sends a request to generate a key to the \texttt{keystore} daemon. This way, the keys' types are hard coded to {\em 2048 bit RSA}. The \texttt{AndroidKeyStore} implements the \texttt{KeyStore} interface. It retrieves the key references from the daemon, but does no permission checking. If the requesting app has never been granted to access the requested key, the access simply fails. Another noteworthy thing is, that it only supports only asymmetric keys.

		Key references means that the returned key objects don't carry the parameters themselves, but instead they are	handles that the OpenSSL JCA provider can use to run the crypto operations on the keys in the keystore, so the Java code (and specifically, the app's code) never sees any crypto parameters at all. The \texttt{KeyChain} allows to retrieve \texttt{PrivateKey} using the \texttt{AndroidKeyStore}, but requests permission to access a key beforehand. The user will see a dialog telling him which app tries to access a key, can choose the one he wants to use and the app gets access to that granted key. 
		
	\subsection{Proposed Implementation Ideas}
		\subsubsection{Reuse KeyChain API}
			Our initial plan was to reuse as much of the KeyChain API as possible. Nevertheless we would need to add support	for symmetric keys and other asymmetric key types in both storage and key generation as well as support for key	exchange handling.

			This turned out to be harder than we thought, as we would need to rewrite significant amount of C++ code in the	\texttt{keystore} daemon for supporting anything else than RSA. Also we would have to rewrite the protocol the \texttt{keystore} uses to communicate with the Java framework.
			
			On top of that, there turns out to be a bug somewhere in Android's OpenSSL engine, which causes {\em dalvik} to	{\em segfault} as soon as encryption or decryption is being run with the returned key references.

		\subsubsection{The manual way}
			% TODO rewrite to match the above
			After many tries, we finally retrieved a working solution in doing everything in our own code and store the keys as blobs in the \texttt{keystore}. This means:
			\begin{enumerate}
				\item Manually generate the key pair, manually store it in the \texttt{keystore} as a PKCS\#8 (not PKCS\#12) encoded blob and the certificate as PEM encoded blob.
				\item For encryption, manually load the certificate from \texttt{keystore}, parse it, feed it to \path{java.security.Cipher}.
				\item For decryption, manually load the private key from \texttt{keystore}, parse it, feed it to \path{java.security.Cipher}.
			\end{enumerate}
			%TODO: Symmetric crypto!

\section{Implementing the framework}

	The framework respectively the backend consists of the \texttt{KeyChain} app for all the crypto operations on the one hand and the management of the keys on the other hand.

	\subsection{Key Chain}
		To reduce responsibility of the apps it makes sense to let the system app (\texttt{KeyChain}) handle everything related to key management:
		\begin{enumerate}
			\item Generate keys
			\item Delete keys
			\item Import/Export of key \emph{pairs}\footnote{Users should be able to export their keys for use on other devices.}
			\item Grant key access to apps
		\end{enumerate}
		Our first sketch didn't quite reflect symmetric encryption, so there was some more work due in refining our API, with the final result being as followed.

		% TODO match completely to current API
		\begin{enumerate}
		\tt
			\item encrypt(keyId, algorithm, padding, plaintext, initVector) \totype ciphertext
			\item decrypt(keyId, algorithm, padding, ciphertext, initVector) \totype plaintext
			\item sign(keyId, algorithm, plaintext) \totype signature
			\item verify(keyId, algorithm, plaintext, signature) \totype isValid
%			\item requestKey() \totype keyId %->This is not in our current api, which is exposed to other apps.
			\item storePublicCertificate(keyId, certificate) \totype void\footnote{Existing methods in \texttt{android.security.KeyChain} can be used for retrieving the certificate / public key}
			\item generateSymmetricKey(keyId, algorithm, keysize) \totype void
			\item retrieveSymmetricKey(keyId, algorithm) \totype key
			\item importSymmetricKey(keyId, key) \totype void
			\item deleteSymmetricKey(keyId) \totype void
			\item mac(keyId, algorithm, plaintext) \totype mac
			\item generateKeyPair(keyId, algorithm, keysize) \totype publicKey
			\item keyAgreementPhase(keyId, algorithm, agreementAlgorithm, publicKey, isLastPhase) \totype publicKey
		\end{enumerate}
		Keys itself are referenced by an string alias (\emph{keyId}). Every key has exactly one alias assigned in the \texttt{keystore}. This alias must be unique.
	
		The functions \texttt{encrypt} and \texttt{decrypt} are used for symmetric as well as for asymmetric crypto. %TODO: Is verify capable of verifying macs?
		The functions \texttt{sign}, \texttt{storePublicCertificate}, \texttt{generateKeyPair} and \texttt{keyAgreementPhase} are exclusive to asymetric crypto. The other functions are just for symmetric crypto operations.
	
	\subsection{Key Management App}
		In addiction to all the new crypto operations, keys have to be assigned to contacts and receive an second alias therefore.
		
		After a key was created or imported, it is possible to assign this key to one or many contacts. Each assignment gets a new string alias which is arbitrary. The alias has to be unique per contact. It is also possible to assign the same key more than once to a contact with the premise, that the alias is different each time. The alias has two purposes:
		\begin{enumerate}
			\item Identify the key.
			\item Act as a usage type.
		\end{enumerate}
		The first should be clear. Act as a \emph{usage type} means, to assign a logic to this key. Each app that interacts with the KeyChain gets its own usage type. For example an crypto e-mail would get \textit{mail-crypt} as usage type. Now whenever an encrypted e-mail is send to a contact, the program only has to check if the usage type is present. If not, no key for this usage is defined and so encryption can't happen.
		%TODO: Explain in greater detail, how keys are assigned to contacts (MIME-Type?)
		
\section{Integrating the SMS app with our API}
	\label{sec-sms-app}
	At first we thought about integrating asymmetric cryptography with the standard e-mail app. Sven Bugiel brought to our attention, that extending the default e-mail app would be quite complicated and would bear a huge overhead. He also suggested to take on SMS as this would be more feasible. As asymmetric crypto bears a huge overhead for SMS (in terms of cost per SMS) we decided to implement symmetric cryptography with the SMS app instead. %TODO: Is this enough for the part of "Why"?
	
	In our scenario we assumed, that the symmetric key would already be exchanged with the other party. So we just had to handle sending and receiving SMS.
	
	The greatest inconvenience with system apps is, that one first has to build the image, once you've developed something. As compiling android even on good systems takes hours, we decided against altering the system app and instead overlaying it. This means:
	\begin{itemize}
		\item For writing encrypted messages, a seperate UI is needed.
		\item For receiving encrypted messages, broadcasts need to be captured.
		\item In every case, the unencrypted messages are stored in the communication log with the respective contact.
	\end{itemize}
	This also means, other than when sending encrypted SMS, the user doesn't have to differ from his known behavior.
	%TODO: Explain exactly, how Sending and Receiving SMS is handled.
	
\section{Key Exchange Scenarios}
	%TODO: If I remember correctly, we should spin some ideas around of how we would exchange keys.
	%Besides Keysigning parties and the usage of NFC, Diffie could be explained a little bit here.
	
\section{Responsibilities}
	%Who did what?
	%Reports - All of us
	%Framework - Kjell, (Cassius?)
	%Crypt-SMS-App - All of us with Kjell doing the most?
	
\section{Further development}
	%TODO: What could come next?
	%Check MAC in API instead of usercode
	%Implement NFC key exchange with system apps so user code would never see certs.

\end{document}

