\documentclass[a4paper]{scrartcl}

\usepackage[english]{babel} %English 
%\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}	%utf8 encoding
\usepackage[colorlinks]%, %Anstatt Boxen um Links, diese einf√§rben
        	{hyperref}		%Anklickbare Links

%\usepackage{
%	amsmath,                 % improves quality of formulas
%   amssymb,                 % mathematical symbols
%   amsfonts,                % mathematical fonts
%   amsthm,                  % macros for theorems, lemmas, etc.
%   graphicx,                % needed to include graphics and images
%}

\title{KeyChain Extension and Integration\\
	Midterm Report\\[4mm]
  \small{Practical Lab on Smartphone Security\\[2mm]
  Winter term 2012/2013}}
\author{Kjell Braden, Marvin Dickhaus, Cassius Puodzius}
\date{\today}


%%% START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
	The goal of this project is to extend the build-in key storage of Android 4.2 in a way that it supports functionality such as signing and decrypting without revealing the needed key to any app.\\
	The second goal is the integration of system apps like Contacts or E-Mail with the newly provided features.
\end{abstract}

\tableofcontents

\section{Introduction}
	Since Android API Level\footnote{\url{http://developer.android.com/guide/topics/manifest/uses-sdk-element.html\#ApiLevels}} 14 (4.0 Ice Cream Sandwich) the KeyChain\footnote{\url{http://developer.android.com/reference/android/security/KeyChain.html}} class exists in Android. The KeyChain class provides access to private keys and their corresponding certificate chains in credential storage.\\
	Whenever in the current implementation an authorized add calls to retrieve the private key, it'll get it. Our goal is to extend the given functionality further with a crypto oracle. With that functionality, apps should call the API with what they wanted to be en/decrypted or signed/verified. In the process of en/decryption and signing the API would return the respective string. With verifying the API would return a boolean.\\
	Besides the new API, we want to alter at least one system app to comply with our enhanced KeyChain.

\section{Initial Situation}
	At the starting point, we were confronted with a quite unfinished, not wholly tested API. Furthermore the KeyChain API lacks in documentation. So we had to figure out, in what way it would be possible to implement our functionality.

	\subsection{Class Overview}
		\begin{description}
			\item[KeyChain] The \texttt{KeyChain} app is the Java API for importing PKCS\#12 containers (private keys, public certificates and ca certificates). The PKCS\#12 format allows the container to be encrypted and/or signed.
				\begin{itemize}
					\item Intents for importing PKCS\#12 containers are handled in \path{com.android.certinstaller} (source at \path{packages/apps/CertInstaller/CertInstaller.java} et al.).
					\item Private as well as public keys (certificates) can be requested (handled in \path{com.android.KeyChain}, source at \path{packages/apps/KeyChain/KeyChainActivity.java}).
					\begin{itemize}
						\item If a private key access was granted, you can load it using \texttt{getPrivate\-Key()}.
						\item Certificates (ie. public keys) can be retrieved through \texttt{getCertificate\-Chain()}, which returns the chain with the main cert itself in the zero slot.
					\end{itemize}
				\item Also contains \texttt{AndroidKeyPairGenerator}, which seems to store keys in \texttt{key\-store} automatically. %Maybe better not say anything that "seems to be" like something.
				\end{itemize}
			\item[keystore] The \texttt{keystore} is the native deamon (written in C) that holds encrypted key information.
				\begin{itemize}
					\item The storage is encrypted with a master key which is derived from the unlock PIN or pattern on the \emph{first successful unlock attempt} of the device. The keystore won't lock again \emph{until the phone is powered off}. This means, the keystore protects for example from rooting, but not from live-debugging.
					\item The class has a \texttt{key} and \texttt{blob} semantic. \texttt{key} is an actual keypair, access is limited, provides (native level!) methods for signing and verification. \texttt{blob} is just random data \texttt{KeyChain} uses the \texttt{key} semantics for private keys and the \texttt{blob} semantic for certificates. %Sorry, I don't really understand that point. Could you please review and correct it, if necessary.
					\item \texttt{keystore} provides an OpenSSL engine called \texttt{keystore}, which should be able to load private keys. %As I see it, this actually receives PKCS#8 containers, doesn't it?
				\end{itemize}
			\item [CertInstaller] The \texttt{CertInstaller} is a system app that lets a user import and install certificates from PKCS\#12 container format files.%TODO: Expand!
		\end{description}

	\subsection{Proposed Implementation Ideas}
		Before we could get any real work done, we needed an angle on how we could implement our enhancements.
		\subsubsection{AndroidKeyPairGenerator \& KeyChain}
			At first we tried to reuse as much code as possible.		
			\begin{enumerate}
				\item Use \path{android.security.AndroidKeyPairGenerator} for key generation and storage.
				\item Use \path{KeyChain.getCertificateChain()} and \path{java.security.Cipher} for encryption.
				\item Use \path{KeyChain.getPrivateKey()} and \path{java.security.Cipher} for decryption.
			\end{enumerate}
			The results were rather frustrating. \texttt{AndroidKeyPairGenerator} isn't really well developed as of yet.
			\begin{itemize}
				\item It's not registered as a \texttt{KeyPairGenerator} provider, so we either have to change the ROM or have to register it for our app only.
				\item It's not configurable in terms of private key parameters (key size!, key type\footnote{Key type is sort of hard coded to RSA for now anyway. If we don't use the given architecture anyway, we might be able to use DSA and ElGamal.})
			\end{itemize}
			In conclusion: While we could live with the rest, fixed key size is not quite what we were hoping for. Also, for some reason, \path{KeyChain.getPrivateKey()} does not work, what results in \texttt{keystore} failing with \texttt{KEY\_NOT\_FOUND}
		
		\subsubsection{KeyPairGenerator \& CertInstaller}
			Instead of using the Android specific \texttt{KeyPairGenerator}, one could also use the default \texttt{KeyPairGenerator}\footnote{\url{http://docs.oracle.com/javase/6/docs/api/java/security/KeyPairGenerator.html}} provided by Java and use \texttt{CertInstaller} to store the keypair.
			
			As a result here, the \texttt{CertInstaller} is restrictive in its usage. One can only process encrypted PKCS\#12 containers with it. As we already have the insides of the container (because we were generating it with \texttt{KeyPairGenerator}) we have no need in packing it, encryt it, just to decrypt and unpack it again.
			
		\subsubsection{Idea 3} %TODO: Correct title
			%TODO:I don't really get the hang of idea 3. What is the problem there?

		\subsubsection{Move code from KeyChain to CertInstaller}
			By moving code from the \texttt{KeyChain} app to the \texttt{CertInstaller} app the key generation and storage works. The problem here is, that \path{KeyChain.getPrivateKey()} won't work. It turns out: \texttt{getPrivateKey()} uses \path{KeyChainService.requestPrivateKey()}, which adds the system uid (1000) to the key. In the end the \texttt{keystore} daemon tries to read \texttt{1000\_1000\_USRPKEY\_alias} instead of \texttt{1000\_USRPKEY\_alias}.
			
			Conclusion: We won't use \texttt{KeyChain.getPrivateKey()}.
			
		\subsubsection{Use our code in CertInstaller}
			\begin{enumerate}
				\item Use our code in \texttt{CertInstaller}.
				\item Manually generate key, send to \texttt{CredentialStorage} for storage.
				\item For decryption, load private key using \texttt{keystore} OpenSSL engine (like \texttt{KeyChain} does).
				\item For encryption, load public key using \path{KeyChain.getCertificateChain()}
			\end{enumerate}
			Conclusions:
			\begin{enumerate}
				\item The \emph{decryption crashes the process} (SIGSEGV, not a java exception)
				\item \texttt{keystore}'s \texttt{key} semantic is broken. The \texttt{keystore} only allows access to the public key, even returning the public key when a private key was requested. The included OpenSSL Java-API parses this as a \texttt{PrivateKey} and returns this. Any privatekey-crypto operation obviously crashes.
			\end{enumerate}
		
		\subsubsection{Do everything manually}
			Obviously none of the above ideas where very fulfilling. As a result we're going to do everything in our own code. That means:
			\begin{enumerate}
				\item Manually generate key, manually store key in \texttt{keystore} as PKCS\#8 (not PKCS\#12) encoded blob and certificate as PEM encoded blob.
				\item For encryption, manually load certificate from \texttt{keystore}, parse it, feed to \path{java.security.Cipher}.
				\item For decryption, manually load private key from \texttt{keystore}, parse it, feed to \path{java.security.Cipher}
			\end{enumerate}
			As a result, this is the only working constellation we could acquire.

\section{Implementing the framework}
	Once we have decided, we're doing this manually, we needed to determine, how our interface should look. On the side of the framework, there isn't terribly much methods that have to be available. The once that have to exposed via an API are:
	\begin{enumerate} %TODO: Did I miss any methods?
		\item Encrypt
		\item Decrypt
		\item Sign
		\item Verify
		\item Start a key selection dialog.
		\item Im/export public \& private key.
		\item Im/export public key only.
		\item Delete key (public \& private at once)
	\end{enumerate}
	Keys itself are referenced by an string alias. The permission to use a key is given on a per app basis and managed by the \texttt{keystore}. Our system app doesn't need to check permissions therefor. If a app doesn't have the permission, to access a key, it'll get handled as if the key were non existent.

\section{Perspective - or - Extend the system apps}
In our further planning and development, we want to integrate the contacts, and stock e-mail app with native support for our crypt oracle. The steps therefor have yet to be evaluated.

\end{document}

